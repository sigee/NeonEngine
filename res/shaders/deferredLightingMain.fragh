#include "sampling.glh"

uniform mat4 R0_lightMatrix;

uniform sampler2D R0_filterTexture;
uniform sampler2D R2_filterTexture;
uniform sampler2D R3_filterTexture;
uniform sampler2D R4_filterTexture;

uniform sampler2D R_shadowMap;
uniform float R_shadowVarianceMin;
uniform float R_shadowLightBleedingReduction;

layout(location = 0) out vec4 outputFS;

bool InRange(float val){
	return val >= 0.0 && val <= 1.0;
}

float CalcShadowAmount(sampler2D shadowMap, vec4 initialShadowMapCoords){
	vec3 shadowMapCoords = (initialShadowMapCoords.xyz/initialShadowMapCoords.w);
	
	if(InRange(shadowMapCoords.z) && InRange(shadowMapCoords.x) && InRange(shadowMapCoords.y)){
		return SampleVarianceShadowMap(shadowMap, shadowMapCoords.xy, shadowMapCoords.z, R_shadowVarianceMin, R_shadowLightBleedingReduction);
	}else{
		return 1.0;
	}
}

void main(){
	vec4 pos = texture(R3_filterTexture, texCoord0);
	
	//vec4 diffuse = texture(R0_filterTexture, texCoord0);
	//vec4 lighting = CalcLightingEffect(texture(R2_filterTexture, texCoord0).rgb, pos.xyz, texture(specMap, texCoord0).x) * CalcShadowAmount(R_shadowMap, shadowMapCoords0);
	
	float shadow = CalcShadowAmount(R_shadowMap, (R0_lightMatrix * pos));
	
	outputFS = texture(R0_filterTexture, texCoord0) * CalcLightingEffect(texture(R2_filterTexture, texCoord0).rgb, pos.xyz, texture(R4_filterTexture, texCoord0).rg) * vec4(shadow, shadow, shadow, shadow);
	
	//float brightness = dot(lighting.rgb, vec3(0.25, 0.25, 0.25));
	
	//if(brightness > 1.0){		
		//outputBloom = (diffuse * lighting)*vec4(0.5, 0.5, 0.5, 1.0);
	//}else{		
		//outputBloom = vec4(0.0, 0.0, 0.0, 0.0);
	//}
}